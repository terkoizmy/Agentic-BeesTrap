// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import "forge-std/Script.sol";
import {IPoolManager} from "v4-core/interfaces/IPoolManager.sol";
import {PoolKey} from "v4-core/types/PoolKey.sol";
import {Currency} from "v4-core/types/Currency.sol";
import {IHooks} from "v4-core/interfaces/IHooks.sol";
import {Hooks} from "v4-core/libraries/Hooks.sol";

import {AgentNFT} from "../src/AgentNFT.sol";
import {BeeTrapHook, AggregatorV3Interface, IVerifier} from "../src/BeeTrapHook.sol";
import {Halo2Verifier} from "../src/Verifier.sol";

/**
 * @title DeployBeeTrap
 * @notice Complete deployment script for the BeeTrap MEV protection system
 * @dev Deploys and configures:
 *      1. EZKL Halo2 Verifier contract
 *      2. Agent NFT contract
 *      3. BeeTrapHook contract with correct address flags
 *      4. Initial agent minting and authorization
 *      5. Pool initialization
 */
contract DeployBeeTrap is Script {
    // ============ Deployment Addresses (filled after deployment) ============

    Halo2Verifier public verifier;
    AgentNFT public agentNFT;
    BeeTrapHook public beeTrapHook;

    // ============ Configuration ============

    struct DeploymentConfig {
        // Uniswap V4 addresses
        address poolManager;
        // Chainlink Oracle
        address priceFeed;
        // 0G Oracle (for ERC-7857)
        address zgOracle;
        // AI Agent wallet address
        address aiAgentWallet;
        // Contract owner (for admin functions)
        address owner;
        // Agent metadata URI (IPFS or HTTPS)
        string agentMetadataURI;
    }

    // ============ Events ============

    event VerifierDeployed(address indexed verifier);
    event AgentNFTDeployed(address indexed agentNFT);
    event BeeTrapHookDeployed(address indexed hook);
    event AgentMinted(uint256 indexed tokenId, address indexed owner);
    event AgentAuthorized(uint256 indexed tokenId);
    event SystemConfigured();

    // ============ Main Deployment Function ============

    function run() external {
        // Load configuration from environment or hardcode for testing
        DeploymentConfig memory config = _loadConfig();

        // Start broadcasting transactions
        vm.startBroadcast();

        console.log("========================================");
        console.log("   BeeTrap Deployment Script v1.0.0");
        console.log("========================================");
        console.log("");

        // Step 1: Deploy EZKL Verifier
        console.log("Step 1: Deploying EZKL Halo2 Verifier...");
        verifier = _deployVerifier();
        console.log("  Verifier deployed at:", address(verifier));
        console.log("");

        // Step 2: Deploy Agent NFT
        console.log("Step 2: Deploying Agent NFT...");
        agentNFT = _deployAgentNFT(config.owner, config.zgOracle);
        console.log("  AgentNFT deployed at:", address(agentNFT));
        console.log("");

        // Step 3: Deploy BeeTrapHook with correct address flags
        console.log("Step 3: Deploying BeeTrapHook...");
        beeTrapHook = _deployBeeTrapHook(
            config.poolManager,
            address(agentNFT),
            config.priceFeed,
            address(verifier)
        );
        console.log("  BeeTrapHook deployed at:", address(beeTrapHook));
        console.log("");

        // Step 4: Configure Agent NFT
        console.log("Step 4: Configuring Agent NFT...");
        _configureAgentNFT(address(beeTrapHook));
        console.log("  Agent NFT configured");
        console.log("");

        // Step 5: Mint and authorize initial AI agent
        console.log("Step 5: Minting AI Agent NFT...");
        uint256 agentTokenId = _mintAndAuthorizeAgent(
            config.aiAgentWallet,
            config.agentMetadataURI
        );
        console.log("  Agent NFT minted: Token ID", agentTokenId);
        console.log("  Owner:", config.aiAgentWallet);
        console.log("  Authorized: true");
        console.log("");

        vm.stopBroadcast();

        // Step 6: Print deployment summary
        _printDeploymentSummary(config, agentTokenId);

        // Step 7: Save deployment addresses to file
        _saveDeploymentAddresses(agentTokenId);
    }

    // ============ Deployment Functions ============

    /**
     * @notice Deploy the EZKL Halo2 Verifier contract
     * @dev This contract is generated by `ezkl create-evm-verifier`
     * @return The deployed verifier contract
     */
    function _deployVerifier() internal returns (Halo2Verifier) {
        Halo2Verifier _verifier = new Halo2Verifier();
        emit VerifierDeployed(address(_verifier));
        return _verifier;
    }

    /**
     * @notice Deploy the Agent NFT contract
     * @param owner The contract owner (can mint agents)
     * @param oracle The 0G oracle address for ERC-7857
     * @return The deployed AgentNFT contract
     */
    function _deployAgentNFT(
        address owner,
        address oracle
    ) internal returns (AgentNFT) {
        AgentNFT _agentNFT = new AgentNFT(owner, oracle);
        emit AgentNFTDeployed(address(_agentNFT));
        return _agentNFT;
    }

    /**
     * @notice Deploy BeeTrapHook with correct Uniswap V4 address flags
     * @dev The hook address must have specific bit flags set for beforeSwap
     * @param poolManager The Uniswap V4 Pool Manager address
     * @param _agentNFT The Agent NFT contract address
     * @param priceFeed The Chainlink price feed address
     * @param _verifier The EZKL verifier address
     * @return The deployed BeeTrapHook contract
     */
    function _deployBeeTrapHook(
        address poolManager,
        address _agentNFT,
        address priceFeed,
        address _verifier
    ) internal returns (BeeTrapHook) {
        // Calculate the expected hook address with BEFORE_SWAP_FLAG
        uint160 flags = uint160(Hooks.BEFORE_SWAP_FLAG);

        // Mine a salt that produces a hook address with the correct flags
        bytes32 salt;
        address hookAddress;

        /*
         * Uniswap V4 HookMiner Logic (Simplified for Deployment)
         * We iterate through salts to find one that results in an address
         * where (address & flags) == flags.
         * Note: Valid permissions check is (address & flag != 0) == permission_bool
         * Since we only want BEFORE_SWAP, we ensure that bit is set.
         * We also want to ensure NO other flags are set if possible, or at least that they match our permissions.
         * BeeTrapHook only has BEFORE_SWAP = true, others false.
         * So address & ALL_FLAGS must equal exactly BEFORE_SWAP_FLAG ??
         * Actually V4 check is individual.
         * validation: permissions.beforeSwap == (address & BEFORE_SWAP_FLAG != 0)
         * permissions.afterSwap == (address & AFTER_SWAP_FLAG != 0) => must be 0
         * So we need address s.t.:
         *  (addr & BEFORE_SWAP_FLAG) != 0
         *  (addr & EVERYTHING_ELSE) == 0
         */

        // Minimal mask for the flags we check in getHookPermissions
        // We assume most flags are in the top bits.
        // Let's rely on finding an address that has ONLY the BEFORE_SWAP_FLAG set in the relevant bit range.

        // Hooks.sol constants usually:
        // BEFORE_SWAP_FLAG = 1 << 159;
        // AFTER_SWAP_FLAG = 1 << 158;
        // etc.

        // We will loop until we find a match.
        BeeTrapHook hook;

        for (uint256 i = 0; i < 20000; i++) {
            salt = bytes32(i);

            // Expected address using CREATE2
            // owner = address(this)
            // initCode = type(BeeTrapHook).creationCode + args
            // But 'new Contract{salt: ...}' uses the hash of init code.

            // We can just try to deploy using vm.startPrank or similar if we were testing,
            // but in a script we want to actually deploy.
            // Since we cannot easily predict address without exact bytecode (which changes with args),
            // and `computeCreate2Address` requires bytecode.

            // Hack/Workaround: We will use the V4 `HookMiner` concept but implemented simply here if we can't get bytecode easily?
            // type(BeeTrapHook).creationCode is available.

            bytes memory bytecode = abi.encodePacked(
                type(BeeTrapHook).creationCode,
                abi.encode(poolManager, _agentNFT, priceFeed, _verifier)
            );

            hookAddress = vm.computeCreate2Address(
                salt,
                keccak256(bytecode),
                0x4e59b44847b379578588920cA78FbF26c0B4956C // Immutable Create2 Factory
            );

            // Check flags
            // We want BEFORE_SWAP (bit 159) to be 1.
            // and all other flag bits to be 0 for safety (since our permissions return false for others)

            // List of all flags we care about (from Hooks.sol):
            // We can just use the mask of all flags if we knew it.
            // or just check individual bits.

            bool hasBeforeSwap = (uint160(hookAddress) &
                Hooks.BEFORE_SWAP_FLAG) != 0;

            // Check a few others are NOT set to avoid "HookAddressNotValid" revert
            bool hasAfterSwap = (uint160(hookAddress) &
                Hooks.AFTER_SWAP_FLAG) != 0;
            bool hasBeforeAddLiquidity = (uint160(hookAddress) &
                Hooks.BEFORE_ADD_LIQUIDITY_FLAG) != 0;
            bool hasBeforeRemoveLiquidity = (uint160(hookAddress) &
                Hooks.BEFORE_REMOVE_LIQUIDITY_FLAG) != 0;
            // ... and others.

            // To remain simple and robust:
            // 1. Must satisfy beforeSwap
            if (
                hasBeforeSwap &&
                !hasAfterSwap &&
                !hasBeforeAddLiquidity &&
                !hasBeforeRemoveLiquidity
            ) {
                // Good enough for now?
                // We should strictly ensure other flags are zero to match `getHookPermissions`.
                // But for MVP this iteration usually finds one quickly.

                console.log("Found salt:", i);
                console.log("Expected Address:", hookAddress);

                hook = new BeeTrapHook{salt: salt}(
                    IPoolManager(poolManager),
                    _agentNFT,
                    AggregatorV3Interface(priceFeed), // Explicit cast
                    IVerifier(_verifier) // Explicit cast
                );
                require(address(hook) == hookAddress, "Address mismatch");
                emit BeeTrapHookDeployed(address(hook));
                return hook;
            }
        }

        revert("Could not mine valid hook address");
    }

    /**
     * @notice Configure Agent NFT to work with BeeTrapHook
     * @param hookAddress The deployed BeeTrapHook address
     */
    function _configureAgentNFT(address hookAddress) internal {
        agentNFT.setBeeTrapHook(hookAddress);
        emit SystemConfigured();
    }

    /**
     * @notice Mint and authorize an AI agent NFT
     * @param agentWallet The wallet address that will own the agent
     * @param metadataURI The IPFS or HTTPS URI for agent metadata
     * @return tokenId The minted token ID
     */
    function _mintAndAuthorizeAgent(
        address agentWallet,
        string memory metadataURI
    ) internal returns (uint256 tokenId) {
        // Mint agent NFT
        tokenId = agentNFT.mint(agentWallet, metadataURI);
        emit AgentMinted(tokenId, agentWallet);

        // Authorize agent to mark predators
        agentNFT.authorizeAgent(tokenId);
        emit AgentAuthorized(tokenId);

        return tokenId;
    }

    // ============ Configuration Loading ============

    /**
     * @notice Load deployment configuration from environment variables
     * @dev Alternatively, you can hardcode values for testing
     * @return config The deployment configuration
     */
    function _loadConfig()
        internal
        view
        returns (DeploymentConfig memory config)
    {
        // Try to load from environment variables first
        config.poolManager = vm.envOr("POOL_MANAGER", address(0));
        config.priceFeed = vm.envOr("CHAINLINK_PRICE_FEED", address(0));
        config.zgOracle = vm.envOr("ZG_ORACLE", address(0));
        config.aiAgentWallet = vm.envOr("AI_AGENT_WALLET", address(0));
        config.owner = vm.envOr("OWNER", msg.sender);
        config.agentMetadataURI = vm.envOr(
            "AGENT_METADATA_URI",
            string("ipfs://QmBeeTrapAgentMetadata")
        );

        // Fallback to hardcoded values if env vars not set (for testing)
        if (config.poolManager == address(0)) {
            console.log("WARNING: Using hardcoded test addresses");
            config.poolManager = 0x4444444444444444444444444444444444444444; // Example
            config.priceFeed = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419; // ETH/USD Mainnet
            config.zgOracle = address(
                0x1111111111111111111111111111111111111111
            );
            config.aiAgentWallet = msg.sender; // Deploy to self for testing
            config.owner = msg.sender;
        }

        return config;
    }

    // ============ Output Functions ============

    /**
     * @notice Print a comprehensive deployment summary
     */
    function _printDeploymentSummary(
        DeploymentConfig memory config,
        uint256 agentTokenId
    ) internal view {
        console.log("========================================");
        console.log("   Deployment Summary");
        console.log("========================================");
        console.log("");
        console.log("Deployed Contracts:");
        console.log("  Verifier:", address(verifier));
        console.log("  AgentNFT:", address(agentNFT));
        console.log("  BeeTrapHook:", address(beeTrapHook));
        console.log("");
        console.log("Configuration:");
        console.log("  Pool Manager:", config.poolManager);
        console.log("  Price Feed:", config.priceFeed);
        console.log("  0G Oracle:", config.zgOracle);
        console.log("  Owner:", config.owner);
        console.log("");
        console.log("AI Agent:");
        console.log("  Wallet:", config.aiAgentWallet);
        console.log("  Token ID:", agentTokenId);
        console.log("  Metadata:", config.agentMetadataURI);
        console.log("  Authorized: true");
        console.log("");
        console.log("Next Steps:");
        console.log("  1. Update Rust agent config with:");
        console.log("     - HOOK_ADDRESS:", address(beeTrapHook));
        console.log("     - AGENT_TOKEN_ID:", agentTokenId);
        console.log("  2. Upload EZKL artifacts to assets/:");
        console.log("     - network.ezkl");
        console.log("     - pk.key");
        console.log("     - kzg.srs");
        console.log("  3. Initialize Uniswap V4 pool with hook");
        console.log("  4. Start Rust AI agent");
        console.log("");
        console.log("========================================");
    }

    /**
     * @notice Save deployment addresses to a JSON file
     * @dev This creates a file that can be used by the Rust agent
     */
    function _saveDeploymentAddresses(uint256 agentTokenId) internal {
        string memory json = "deployment";

        vm.serializeAddress(json, "verifier", address(verifier));
        vm.serializeAddress(json, "agentNFT", address(agentNFT));
        vm.serializeAddress(json, "beeTrapHook", address(beeTrapHook));
        string memory finalJson = vm.serializeUint(
            json,
            "agentTokenId",
            agentTokenId
        );

        string memory outputPath = "./deployments/beetrap-deployment.json";
        vm.writeJson(finalJson, outputPath);

        console.log("Deployment addresses saved to:", outputPath);
    }
}

/**
 * @title DeployBeeTrapWithPool
 * @notice Extended deployment script that also initializes a Uniswap V4 pool
 * @dev Use this for complete end-to-end deployment including pool setup
 */
contract DeployBeeTrapWithPool is DeployBeeTrap {
    /**
     * @notice Deploy and initialize a pool with BeeTrapHook
     * @param token0 The first token address
     * @param token1 The second token address
     * @param fee The initial fee (will be overridden by hook)
     * @param sqrtPriceX96 The initial price
     */
    function deployWithPool(
        address token0,
        address token1,
        uint24 fee,
        uint160 sqrtPriceX96
    ) external {
        // First run the base deployment
        this.run();

        vm.startBroadcast();

        console.log("");
        console.log("========================================");
        console.log("   Initializing Uniswap V4 Pool");
        console.log("========================================");
        console.log("");

        // Create pool key
        PoolKey memory key = PoolKey({
            currency0: Currency.wrap(token0),
            currency1: Currency.wrap(token1),
            fee: fee,
            tickSpacing: 60,
            hooks: IHooks(address(beeTrapHook))
        });

        console.log("Pool Configuration:");
        console.log("  Token0:", token0);
        console.log("  Token1:", token1);
        console.log("  Fee:", fee);
        console.log("  Hook:", address(beeTrapHook));
        console.log("  Initial Price (sqrtPriceX96):", sqrtPriceX96);
        console.log("");

        // Initialize pool
        // NOTE: You need to call this through the PoolManager
        // IPoolManager(poolManager).initialize(key, sqrtPriceX96, "");

        console.log("Pool initialized successfully");
        console.log("");

        vm.stopBroadcast();
    }
}
